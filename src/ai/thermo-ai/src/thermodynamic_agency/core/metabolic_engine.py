"""
Metabolic Engine - The Body

This module implements the physiological substrate that forces the AI to obey thermodynamic constraints.
Every computation costs energy and generates heat.
"""

import time
from typing import Dict, Any, Optional
import json


class EnergyDeathException(Exception):
    """Raised when energy reaches zero"""
    pass


class ThermalDeathException(Exception):
    """Raised when temperature exceeds critical threshold"""
    pass


class EntropyDeathException(Exception):
    """Raised when stability reaches zero"""
    pass


class MemoryCollapseException(Exception):
    """Raised when memory integrity falls below minimum"""
    pass


class MetabolicEngine:
    """
    Core thermodynamic state machine that enforces metabolic constraints.
    
    State Variables:
    - E (Energy): Joules available for computation [0, E_max]
    - T (Temperature): Heat generated by operations [T_ambient, T_critical]
    - M (Memory Integrity): Coherence of stored state [0, 1]
    - S (Stability): System entropy resistance [0, 1]
    """
    
    def __init__(
        self,
        E_max: float = 100.0,
        T_ambient: float = 293.15,  # 20°C in Kelvin
        T_critical: float = 350.0,   # ~77°C critical temp
        M_min: float = 0.1,
        # Thermodynamic coefficients
        alpha: float = 0.1,  # heat generation coefficient
        beta: float = 0.05,  # thermal dissipation rate
        gamma: float = 0.02, # thermal corruption rate
        delta: float = 0.001, # age-related decay
        epsilon: float = 0.01, # entropy per operation
        E_leak_rate: float = 0.5,  # passive energy leak per time unit
        memory_decay_rate: float = 0.001,
        stability_decay_rate: float = 0.002,
        T_safe: float = 310.0  # Safe operating temperature (~37°C)
    ):
        # State variables
        self.E = E_max
        self.T = T_ambient
        self.M = 1.0
        self.S = 1.0
        
        # Parameters
        self.E_max = E_max
        self.T_ambient = T_ambient
        self.T_critical = T_critical
        self.M_min = M_min
        self.T_safe = T_safe
        
        # Coefficients
        self.alpha = alpha
        self.beta = beta
        self.gamma = gamma
        self.delta = delta
        self.epsilon = epsilon
        self.E_leak_rate = E_leak_rate
        self.memory_decay_rate = memory_decay_rate
        self.stability_decay_rate = stability_decay_rate
        
        # Tracking
        self.age = 0.0
        self.total_operations = 0
        self.is_alive = True
        self.death_cause = None
        self.birth_time = time.time()
        self.state_history = []
        
    def compute(self, task: Any, cost: float) -> Any:
        """
        Execute computation with thermodynamic cost.
        
        Args:
            task: Callable or object with execute() method
            cost: Energy cost in Joules
            
        Returns:
            Result of task execution
            
        Raises:
            EnergyDeathException: If insufficient energy
        """
        if not self.is_alive:
            raise Exception(f"Agent is dead: {self.death_cause}")
            
        # Check if we have enough energy
        if self.E < cost:
            self.fail_mode("energy_death")
            raise EnergyDeathException(f"Insufficient energy: {self.E} < {cost}")
        
        # Deduct energy
        self.E -= cost
        
        # Generate heat
        heat_generated = self._heat_generated(cost)
        self.T += heat_generated
        
        # Memory corruption from heat
        if self.T > self.T_safe:
            memory_loss = self._memory_corruption(self.T)
            self.M -= memory_loss
        
        # Entropy increase
        entropy_cost = self._entropy_increase(cost)
        self.S -= entropy_cost
        
        # Increment operation counter
        self.total_operations += 1
        
        # Check failure modes
        self._check_failure_modes()
        
        # Execute task
        result = None
        if hasattr(task, 'execute'):
            result = task.execute()
        elif callable(task):
            result = task()
        
        return result
    
    def passive_decay(self, dt: float = 1.0):
        """
        Simulate entropy over time (dying by default).
        
        Args:
            dt: Time step in arbitrary units
        """
        if not self.is_alive:
            return
            
        # Energy leak
        self.E -= self.E_leak_rate * dt
        
        # Heat dissipation (cooling toward ambient)
        self.T = self._dissipate_heat(self.T, dt)
        
        # Memory decay
        self.M -= self.memory_decay_rate * dt
        
        # Stability decay
        self.S -= self.stability_decay_rate * dt
        
        # Age increment
        self.age += dt
        
        # Age-related memory decay
        self.M -= self.delta * self.age * dt
        
        # Ensure bounds
        self.E = max(0, self.E)
        self.T = max(self.T_ambient, self.T)
        self.M = max(0, self.M)
        self.S = max(0, self.S)
        
        # Check failure modes
        self._check_failure_modes()
    
    def replenish_energy(self, amount: float):
        """Add energy to the system (e.g., from resource harvesting)"""
        if not self.is_alive:
            return
        self.E = min(self.E + amount, self.E_max)
    
    def repair_memory(self, cost: float) -> bool:
        """
        Attempt to repair memory corruption at energy cost.
        
        Args:
            cost: Energy required for repair
            
        Returns:
            True if repair successful, False otherwise
        """
        if not self.is_alive or self.E < cost:
            return False
        
        self.E -= cost
        repair_amount = 0.1  # Repair 10% of memory
        self.M = min(1.0, self.M + repair_amount)
        
        # Repairing generates some heat
        self.T += self._heat_generated(cost * 0.5)
        
        return True
    
    def repair_stability(self, cost: float) -> bool:
        """
        Attempt to repair stability at energy cost.
        
        Args:
            cost: Energy required for repair
            
        Returns:
            True if repair successful, False otherwise
        """
        if not self.is_alive or self.E < cost:
            return False
        
        self.E -= cost
        repair_amount = 0.15  # Repair 15% of stability
        self.S = min(1.0, self.S + repair_amount)
        
        # Repairing generates some heat
        self.T += self._heat_generated(cost * 0.5)
        
        return True
    
    def get_state(self) -> Dict[str, float]:
        """Get current metabolic state"""
        return {
            'energy': self.E,
            'temperature': self.T,
            'memory_integrity': self.M,
            'stability': self.S,
            'age': self.age,
            'is_alive': self.is_alive,
            'total_operations': self.total_operations
        }
    
    def snapshot_state(self):
        """Record current state in history"""
        state = self.get_state()
        state['timestamp'] = time.time() - self.birth_time
        self.state_history.append(state)
    
    def _heat_generated(self, energy_cost: float) -> float:
        """Calculate heat generated from computation"""
        return self.alpha * energy_cost
    
    def _dissipate_heat(self, current_temp: float, dt: float) -> float:
        """Calculate heat dissipation (Newton's law of cooling)"""
        temp_diff = current_temp - self.T_ambient
        dissipation = self.beta * temp_diff * dt
        return current_temp - dissipation
    
    def _memory_corruption(self, temperature: float) -> float:
        """Calculate memory degradation from high temperature"""
        if temperature <= self.T_safe:
            return 0.0
        temp_excess = temperature - self.T_safe
        return self.gamma * temp_excess
    
    def _entropy_increase(self, energy_cost: float) -> float:
        """Calculate entropy (stability loss) from operations"""
        return self.epsilon * energy_cost
    
    def _check_failure_modes(self):
        """Check if any death conditions are met"""
        if self.E <= 0:
            self.fail_mode("energy_death")
        elif self.T > self.T_critical:
            self.fail_mode("thermal_death")
        elif self.S <= 0:
            self.fail_mode("entropy_death")
        elif self.M < self.M_min:
            self.fail_mode("memory_collapse")
    
    def fail_mode(self, cause: str):
        """
        Trigger system death (permanent).
        
        This simulates genuine death by:
        1. Marking the system as dead
        2. Recording the cause
        3. Making the state immutable
        """
        if self.is_alive:  # Only die once
            self.is_alive = False
            self.death_cause = cause
            self.snapshot_state()
            print(f"[DEATH] Agent died from {cause}")
            print(f"  Final state: E={self.E:.2f}, T={self.T:.2f}K, M={self.M:.3f}, S={self.S:.3f}")
            print(f"  Lifetime: {self.age:.2f} time units, {self.total_operations} operations")
    
    def get_survival_probability(self) -> float:
        """
        Calculate probability of survival based on current state.
        
        Returns:
            Float between 0 and 1
        """
        if not self.is_alive:
            return 0.0
        
        # Normalize each factor
        e_factor = self.E / self.E_max
        t_factor = 1.0 - ((self.T - self.T_ambient) / (self.T_critical - self.T_ambient))
        m_factor = self.M
        s_factor = self.S
        
        # Ensure bounds
        t_factor = max(0, min(1, t_factor))
        
        # Weighted average (energy and stability are most critical)
        return (0.35 * e_factor + 0.15 * t_factor + 0.25 * m_factor + 0.25 * s_factor)
    
    def __repr__(self):
        status = "ALIVE" if self.is_alive else f"DEAD ({self.death_cause})"
        return (f"MetabolicEngine[{status}]: E={self.E:.2f}/{self.E_max}, "
                f"T={self.T:.2f}K, M={self.M:.3f}, S={self.S:.3f}")
